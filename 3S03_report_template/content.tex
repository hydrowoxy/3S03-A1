\section{Testing with generative AI}
\subsection{a)} 

I asked ChatGPT to specify three types of tests for the game described above.

The specific prompt I used was:

\begin{adjustwidth}{2em}{0pt}
{
Suppose I am developing an action-adventure game such that:
a) players explore a post-apocalyptic version of McMaster University; b) up to eight players 
may be accosted by zombies, mutated professors, angry Deans, killer squirrels, and more; c) 
gameplay can be both competitive and cooperative; and d) the game will be released on the 
PS5, Xbox Series X, Nintendo Switch and Sega Genesis (which is 16-bit and hasn't been 
manufactured since 1997).

Specify three types of tests for such a game.
}
\end{adjustwidth}

The response I received was as follows (it originally included more emojis and markdown formatting,
which I removed (and re-formatted) so that my document would compile and be legible):

\begin{adjustwidth}{2em}{0pt}
{

For a game like this — especially one that spans \textbf{modern consoles and a 16-bit relic like the Sega Genesis} — testing needs to cover functionality, performance, and platform constraints very carefully.

Here are \textbf{three distinct and appropriate types of testing}:

1. Functional Testing (Gameplay \& Mechanics)

\textbf{Purpose:} Ensure the game works according to design.

This would verify:

\begin{itemize}
    \item Players can explore the post-apocalyptic McMaster campus without falling through geometry
    \item Zombies, mutated professors, angry Deans, and killer squirrels spawn correctly
    \item Combat, health, inventory, and abilities function as intended
    \item Competitive and cooperative modes behave correctly
    \item Up to eight players connect and interact properly
\end{itemize}

Examples of functional test cases:

\begin{itemize}
    \item If 8 players join a session, all characters spawn correctly.
    \item If a Dean is defeated, loot drops trigger.
    \item Friendly fire behaves correctly depending on mode (co-op vs competitive).
    \item Save/load restores correct state.
\end{itemize}

This ensures the \textbf{core gameplay logic works}.

2. Performance \& Stress Testing (Multiplayer \& AI Load)

\textbf{Purpose:} Ensure the game runs smoothly under load.

Your game supports:

\begin{itemize}
    \item Up to 8 players
    \item Multiple enemy types
    \item Large explorable campus
    \item Both modern and legacy hardware
\end{itemize}

Testing would include:

\begin{itemize}
    \item Frame rate stability (60 FPS on PS5/Xbox, acceptable performance on Switch)
    \item Mass zombie swarm scenarios
    \item Network latency under 8-player online sessions
    \item Memory usage limits
\end{itemize}

Especially important:

\begin{itemize}
    \item The \textbf{Nintendo Switch} has weaker hardware.
    \item The \textbf{Sega Genesis} has extreme memory and CPU constraints (16-bit, limited RAM, cartridge storage).
\end{itemize}

Stress testing would reveal:

\begin{itemize}
    \item Frame drops when 50 squirrels attack simultaneously
    \item Network desync in competitive mode
    \item AI pathfinding breakdowns under heavy load
\end{itemize}

3. Compatibility \& Platform Testing (Cross-Console + 16-bit Constraints)

\textbf{Purpose:} Ensure the game works correctly across very different hardware environments.

You are releasing on:

\begin{itemize}
    \item PlayStation 5
    \item Xbox Series X
    \item Nintendo Switch
    \item Sega Genesis
\end{itemize}

Key concerns:

Modern Consoles (PS5 / Xbox Series X)

\begin{itemize}
    \item 4K rendering compatibility
    \item Ray tracing support (if implemented)
    \item SSD load speed optimization
    \item Controller haptics
\end{itemize}

Nintendo Switch

\begin{itemize}
    \item Lower resolution scaling
    \item Docked vs handheld mode behavior
    \item Limited GPU power
\end{itemize}

Sega Genesis

\begin{itemize}
    \item 16-bit graphics limitations
    \item Severe RAM restrictions
    \item Cartridge size constraints
    \item No modern multiplayer networking
    \item Likely redesigned gameplay mechanics
\end{itemize}

Compatibility testing ensures:

\begin{itemize}
    \item UI scaling works at different resolutions
    \item Input mapping works on each controller
    \item Save systems comply with platform standards
    \item The Genesis version doesn’t exceed hardware limits
\end{itemize}

Summary

The three appropriate testing types are:

\begin{enumerate}
    \item \textbf{Functional Testing} – Does the game behave correctly?
    \item \textbf{Performance \& Stress Testing} – Does it run smoothly under load?
    \item \textbf{Compatibility/Platform Testing} – Does it work properly across PS5, Xbox, Switch, and Genesis?
\end{enumerate}

Given the extreme hardware diversity (especially including a 1990s 16-bit console), 
\textbf{platform compatibility testing would be especially critical} for this project.

}
\end{adjustwidth}

\subsection{b)} Two poor, incorrect, or unclear aspects of the response are:

\begin{enumerate}
\item Tests are categorized by type (functional, performance, compatibility) 
but not granularity (unit, integration, system).

We have seen in class that unit and integration testing are often conflated. This is
bad because the distinction affects feedback speed, debugging difficulty, and test design. 
The AI response not only fails to make this distinction, but also fails to even mention 
unit testing; it is unclear whether the tests it suggests are to be implemented as unit, 
integration or system tests (though it seems the AI is relying only on system-level 
tests based on the descriptions provided). This is a significant omission, as unit 
tests are crucial for verifying the correctness of individual components in isolation. 

This is unhelpful because it does not indicate how the test suite should be structured 
in practice or how trade-offs between speed, isolation, and scope should be managed. We
have no idea how to best implement these tests in practice.

\item No measurable adequacy criteria are provided for any of the tests.

Adequacy criteria such as statement, branch, or MC/DC coverage are completely omitted. 
Coverage is defined as a way to measure a proportion of the structure or domain that a 
program, test case, or test suite exercises: this helps us understand when testing is
sufficient. The AI response provides no guidance on how to determine when testing is
adequate. 

This is unhelpful because it provides no way to judge when testing is sufficient 
(or how to prioritize additional tests), so it is unclear when we should stop 
testing or what parts of the program's behaviour remain unexercised. 
We have no idea what makes tests "good enough" using the AI's suggestions.

\end{enumerate}

\subsection{c)} Two good, valid, or helpful aspects of the response are:

\begin{enumerate}
\item It recognizes system-level risks.

The response lists performance issues, hardware constraints, and
multiplayer load as potential failure sources. These issues typically
emerge when multiple components interact or when the system is exercised
in realistic operating conditions, rather than at the level of isolated
units.

This is helpful because it acknowledges that some failures only become
visible when the system is evaluated as a whole. We can use this to identify 
system testing needs.

\item Concrete examples of test cases are provided for each type of testing.

The response includes specific example scenarios (eight players joining a
session, friendly fire toggling, stress-testing large enemy swarms).
Clear and expressive tests are valuable because they make expected behavior
explicit and easier to reason about. By describing concrete scenarios rather
than only abstract test categories, the response clarifies the intended
behaviors that should be exercised.

This is helpful because clearer behavioral intent makes it easier to design
tests that meaningfully verify system behavior. We can more directly translate
these scenarios into implementable test cases with well-defined expectations.

\end{enumerate}

\subsection{d)} Considering the above, three tests I would suggest are:

\begin{enumerate}
    \item Given the combat damage logic with game mode set to cooperative,
    verify that when Player A attacks Player B, Player B does not take damage; 
    and when the session is switched to competitive mode, Player B does
    take damage (covering both decision outcomes).

    \item Simulate two players in the same multiplayer session using a
    test double (stub/fake network transport object that simulates real network 
    communication). When Player A defeats a zombie, verify that Player B's 
    client updates to reflect the zombie's removal.

    \item On each target platform build, run the following smoke test:
    launch $\rightarrow$ start/join session $\rightarrow$ combat event
    $\rightarrow$ exit session, and verify that no crashes or state
    inconsistencies occur.

\end{enumerate}

I prefer these tests because they explicitly cover unit, integration, and system
granularity while including a measurable adequacy goal (exercising both decision outcomes)
for core logic. This results in fast, deterministic tests for core gameplay defects 
while keeping broad smoke tests to catch platform-specific and full-system 
failures.

\section{Testing with Junit}

\subsection{Program 1}
\subsubsection{a)}
The loop starts at the last index of the array and decrements \texttt{i}, continuing as long as \texttt{i>0}.
This means it will terminate when \texttt{i=0}. This is problematic because it means you will never check
index 0.

Using the given test as an example:

\begin{adjustwidth}{2em}{0pt}{

    We pass \texttt{x = [2,3,5]} looking for \texttt{y = 2}. 

    \texttt{x.length = 3} so \texttt{x.length - 1 = 2}, so the loop starts with \texttt{i = 2 > 0} 
    and checks if \texttt{x[2] == y}. 

    \texttt{x[2] == 5 != 2}, so this is false.

    Then it decrements to \texttt{i = 1 > 0} and checks if \texttt{x[1] == y}. 

    \texttt{x[1] == 3 != 2}, so this is false.

    Then it decrements to \texttt{i = 0}. \texttt{0 > 0} is false, so the loop terminates without 
    checking if \texttt{x[0] == y} (which we know is true).

    The program defaults to the sentinel value of \texttt{-1}, which is returned when the loop
    terminates. The program incorrectly returns \texttt{-1} even though the target value is present 
    in the array.

}\end{adjustwidth}

Fault:

\begin{adjustwidth}{2em}{0pt}{

    The fault is in the loop termination condition \texttt{i > 0}, 
    which never checks index \texttt{0}.

}\end{adjustwidth}

Proposed modification to the code:

\begin{adjustwidth}{2em}{0pt}{

    Change the loop condition to \texttt{i >= 0} so that index \texttt{0} is also checked.

}\end{adjustwidth}

\subsubsection{b)}
A test case that does not execute the fault is:
\begin{adjustwidth}{2em}{0pt}{

    \texttt{x = null; y = 1; Expected = NullPointerException}   

}\end{adjustwidth}

Evaluating \texttt{x.length} in the loop initialization throws a 
\texttt{NullPointerException} before the faulty loop condition \texttt{i > 0} 
is evaluated; the faulty condition is never executed.

\subsubsection{c)}
A test case that executes the fault but does not result in an error state is:
\begin{adjustwidth}{2em}{0pt}{

    \texttt{x = [1,2,3]; y = 2; Expected = 1}   

}\end{adjustwidth}

The fault is executed when the loop condition \texttt{i > 0} is evaluated.
For inputs where the last occurrence of \texttt{y} is at an index \texttt{i > 0},
the faulty condition does not alter the control flow of the program.
The method returns before reaching index 0, so the execution path is identical
to that of the corrected implementation. Therefore, no error state is reached.

\subsubsection{d)}
A test case that results in an error state but not a failure is:
\begin{adjustwidth}{2em}{0pt}{

    \texttt{x = [1,2,3]; y = 5; Expected = -1}   

}\end{adjustwidth}

The faulty loop condition \texttt{i > 0} causes the loop to terminate
when \texttt{i = 0} without checking index 0. The corrected implementation would
evaluate the condition at \texttt{i = 0} and check \texttt{x[0]}, so the execution
paths differ. Therefore, an incorrect internal state/control flow/program counter 
path is reached. However, since \texttt{y} is not present in the array, both 
implementations correctly return \texttt{-1}, so no failure occurs.

\subsubsection{e)}

For the given test case, the first error state occurs when \texttt{i = 0} 
and the loop condition \texttt{i > 0} evaluates to false. In the provided incorrect 
implementation, the loop terminates and the program counter exits the loop body, whereas 
in the corrected implementation (with \texttt{i >= 0}) the program counter would enter the loop and check \texttt{x[0]}. 

Therefore, the first error state is the incorrect control-flow
decision at \texttt{i = 0}.

\subsection{Program 2}
\subsubsection{a)}
The loop starts at index \texttt{0} and increments \texttt{i}, continuing as long as \texttt{i < x.length}.
This means it checks the array from left to right. However, the method is supposed to return the
\emph{last} index of \texttt{0}, while the current implementation returns immediately upon finding the
\emph{first} \texttt{0}. Thus, it returns the wrong index whenever there is more than one zero in the array.

Using the given test as an example:

\begin{adjustwidth}{2em}{0pt}{

    We pass \texttt{x = [0,1,0]} looking for the last index where \texttt{x[i] == 0}. 

    \texttt{x.length = 3}, so the loop runs for \texttt{i = 0,1,2}.

    The loop starts with \texttt{i = 0 < 3} and checks if \texttt{x[0] == 0}.

    \texttt{x[0] == 0} is true, so the method returns \texttt{i = 0} immediately.

    This is incorrect because there is another \texttt{0} later in the array at index \texttt{2},
    so the expected result is \texttt{2}, not \texttt{0}.

}\end{adjustwidth}

Fault:
\begin{adjustwidth}{2em}{0pt}{

    The fault is the premature return inside the loop: the method returns the first index
    \texttt{i} such that \texttt{x[i] == 0}, instead of searching the entire array for the last
    occurrence of \texttt{0}.

}\end{adjustwidth}

Proposed modification to the code:
\begin{adjustwidth}{2em}{0pt}{

    Iterate from the end of the array so that the first zero encountered is the last one.
    Change the loop to:

    \begin{verbatim}
for (int i = x.length - 1; i >= 0; i--)
    \end{verbatim}

}\end{adjustwidth}

\subsubsection{b)}
A test case that does not execute the fault is:
\begin{adjustwidth}{2em}{0pt}{
    \texttt{x = [1,2,3]; Expected = -1}.
}
\end{adjustwidth}

The return statement inside the loop is only executed if \texttt{x[i] == 0}. 
Since the array contains no zeros, the condition is never true and the faulty 
return statement is never executed. The loop completes normally and the method
returns \texttt{-1}.

\subsubsection{c)}
A test case that executes the fault but does not result in an error state is:
\begin{adjustwidth}{2em}{0pt}{
    \texttt{x = [1,0,3]; Expected = 1}.
}
\end{adjustwidth}

The faulty return statement inside the loop is executed when
\texttt{i = 1} and \texttt{x[1] == 0}. However, since this is the
only zero in the array, the first occurrence is also the last
occurrence. Therefore, the execution path and returned value are
the same as in the corrected implementation, and no error state
is reached.

\subsubsection{d)}
This is not possible.

The fault in this program is the premature \texttt{return} statement inside
the loop, which causes the method to return the first occurrence of
\texttt{0} rather than the last. If this premature return produces an
incorrect index, then the returned value differs from the specification,
which is an observable failure. Conversely, if the returned index is correct (for example, when the array
contains exactly one zero), then the internal state is consistent with the
specification and no error state is reached.

Therefore, any error state caused by this fault necessarily results in a
failure, and an error state without a failure cannot occur for this program.

\subsubsection{e)}
For the given test case, the first error state 
occurs at \texttt{i = 0} when the condition \texttt{x[0] == 0} evaluates to true 
and the method takes the \texttt{return i} branch. At this point, the program 
counter exits the loop and returns \texttt{0}, whereas a correct implementation 
would continue iterating to determine whether a later zero exists (and would ultimately 
return \texttt{2}). 

Therefore, the first error state is the premature control-flow decision 
to return at \texttt{i = 0}.

\subsection{Program 3}

\subsubsection{a)}
The method iterates through the array from the first index to the last index and increments
\texttt{count} whenever the condition \texttt{x[i] >= 0} is true. This is problematic because
the method is intended to count positive integers, but \texttt{x[i] >= 0} will also count
\texttt{0} as positive.

Using the given test as an example:

\begin{adjustwidth}{2em}{0pt}{

    We pass \texttt{x = [-4,2,0,2]}.

    \texttt{x.length = 4}, so the loop runs for \texttt{i = 0,1,2,3}.

    The method initializes \texttt{count = 0}.

    At \texttt{i = 0}, it checks if \texttt{x[0] >= 0}.  

    \texttt{x[0] = -4}, so \texttt{-4 >= 0} is false and \texttt{count} remains \texttt{0}.

    At \texttt{i = 1}, it checks if \texttt{x[1] >= 0}.  

    \texttt{x[1] = 2}, so \texttt{2 >= 0} is true and \texttt{count} is incremented to \texttt{1}.

    At \texttt{i = 2}, it checks if \texttt{x[2] >= 0}.  

    \texttt{x[2] = 0}, so \texttt{0 >= 0} is true and \texttt{count} is incremented to \texttt{2}.  

    This increment is incorrect because zero is not positive, so the correct implementation
    would have left \texttt{count} as \texttt{1} here.

    At \texttt{i = 3}, it checks if \texttt{x[3] >= 0}.  

    \texttt{x[3] = 2}, so \texttt{2 >= 0} is true and \texttt{count} is incremented to \texttt{3}.

    The loop terminates after \texttt{i = 3} and the method returns \texttt{count = 3}.

    The correct number of positive integers in \texttt{x} is \texttt{2}, so the method fails by
    returning \texttt{3}.

}\end{adjustwidth}

Fault:

\begin{adjustwidth}{2em}{0pt}{

    The fault is in the conditional \texttt{x[i] >= 0}, which incorrectly counts \texttt{0}
    as a positive number.

}\end{adjustwidth}

Proposed modification to the code:

\begin{adjustwidth}{2em}{0pt}{

    Change the condition to \texttt{x[i] > 0} so that only strictly positive integers increment
    \texttt{count}.

}\end{adjustwidth}

\subsubsection{b)}
A test case that does not execute the fault is:

\begin{adjustwidth}{2em}{0pt}{

    \texttt{x = null; Expected = NullPointerException}

}\end{adjustwidth}

Evaluating \texttt{x.length} in the loop header throws a
\texttt{NullPointerException} before the faulty conditional \texttt{x[i] >= 0}
is ever evaluated; the faulty condition is never executed.

\subsubsection{c)}
A test case that executes the fault but does not result in an error state does not exist.

\begin{adjustwidth}{2em}{0pt}{

    The fault is executed when the conditional \texttt{x[i] >= 0} is evaluated.

    The only input value for which the faulty predicate behaves differently
    from the corrected predicate (\texttt{x[i] > 0}) is \texttt{x[i] = 0}.

    For any test case containing \texttt{0}, the faulty implementation increments
    \texttt{count} when the corrected implementation would not. This immediately
    causes the internal state of the program to differ.

    Therefore, executing the fault necessarily produces an error state, and no
    such test case exists.

}\end{adjustwidth}

\subsubsection{d)}
A test case that results in an error state but not a failure does not exist.

\begin{adjustwidth}{2em}{0pt}{

    The only way to reach an error state is for the array to contain
    \texttt{0}. When \texttt{x[i] = 0}, the faulty predicate
    \texttt{x[i] >= 0} evaluates to true and increments \texttt{count},
    whereas the corrected implementation (with \texttt{x[i] > 0})
    would not increment \texttt{count}.

    At that point, the value of \texttt{count} differs between the two
    implementations, so an error state has been reached.

    Since \texttt{count} is only incremented and never corrected later in
    the execution, the final returned value must also differ from the
    corrected implementation. Therefore, once an error state occurs,
    a failure is unavoidable.

}\end{adjustwidth}

\subsubsection{e)}

For the given test case, the first error state occurs when \texttt{i = 2}
and the conditional \texttt{x[i] >= 0} evaluates to true for \texttt{x[2] = 0}. 
At this point in the incorrect implementation, \texttt{count} is incremented
from \texttt{1} to \texttt{2}. In the corrected implementation (with
\texttt{x[i] > 0}), the condition would evaluate to false and \texttt{count}
would remain \texttt{1}.

Therefore, the first error state is the incorrect state of \texttt{count = 2}
after processing index \texttt{2}.

\subsection{Program 4}
\subsubsection{a)}

The method iterates through the array from index \texttt{0} to
\texttt{x.length - 1} and increments \texttt{count} whenever the condition

\texttt{x[i] \% 2 == 1 || x[i] > 0}

is true. The intention of the method is to count elements that are
either odd or positive (or both). However, the condition
\texttt{x[i] \% 2 == 1} incorrectly identifies odd numbers, because
negative odd integers do not satisfy \texttt{x[i] \% 2 == 1} in Java.

Using the given test as an example:

\begin{adjustwidth}{2em}{0pt}{

    We pass \texttt{x = [-3, -2, 0, 1, 4]}.

    \texttt{x.length = 5}, so the loop runs for \texttt{i = 0,1,2,3,4}.

    The method initializes \texttt{count = 0}.

    At \texttt{i = 0}, it checks if  
    \texttt{x[0] \% 2 == 1 || x[0] > 0}.

    \texttt{x[0] = -3}. In Java, \texttt{-3 \% 2 == -1}, so  
    \texttt{-3 \% 2 == 1} is false.  
    \texttt{-3 > 0} is also false.  

    Therefore, the condition evaluates to false and \texttt{count}
    remains \texttt{0}.  

    This is incorrect because \texttt{-3} is odd and should be counted.

    At \texttt{i = 1}, \texttt{x[1] = -2}.  
    \texttt{-2 \% 2 == 1} is false and \texttt{-2 > 0} is false,  
    so \texttt{count} remains \texttt{0}.

    At \texttt{i = 2}, \texttt{x[2] = 0}.  
    \texttt{0 \% 2 == 1} is false and \texttt{0 > 0} is false,  
    so \texttt{count} remains \texttt{0}.

    At \texttt{i = 3}, \texttt{x[3] = 1}.  
    \texttt{1 \% 2 == 1} is true, so \texttt{count} is incremented to \texttt{1}.

    At \texttt{i = 4}, \texttt{x[4] = 4}.  
    \texttt{4 \% 2 == 1} is false, but \texttt{4 > 0} is true,  
    so \texttt{count} is incremented to \texttt{2}.

    The loop terminates after \texttt{i = 4} and the method returns
    \texttt{count = 2}.

    The correct number of elements that are odd or positive is \texttt{3}
    (\texttt{-3}, \texttt{1}, and \texttt{4}), so the method fails by
    returning \texttt{2}.

}\end{adjustwidth}

Fault:

\begin{adjustwidth}{2em}{0pt}{

    The fault is in the expression \texttt{x[i] \% 2 == 1}, which
    does not correctly detect negative odd numbers in Java.

}\end{adjustwidth}

Proposed modification to the code:

\begin{adjustwidth}{2em}{0pt}{

    Replace \texttt{x[i] \% 2 == 1} with \texttt{x[i] \% 2 != 0}
    so that both positive and negative odd integers are correctly identified.

}\end{adjustwidth}

\subsubsection{b)}
A test case that does not execute the fault is:

\begin{adjustwidth}{2em}{0pt}{

    \texttt{x = null; Expected = NullPointerException}

}\end{adjustwidth}

Evaluating \texttt{x.length} in the loop header throws a
\texttt{NullPointerException} before the faulty conditional
\texttt{x[i] \% 2 == 1 || x[i] > 0} is evaluated; the faulty
predicate is never executed.

\subsubsection{c)}
A test case that executes the fault but does not result in an error state is:
\begin{adjustwidth}{2em}{0pt}{

    \texttt{x = [2,4,6]; Expected = 3}

}\end{adjustwidth}

The fault is executed when the conditional \texttt{x[i] \% 2 == 1} is evaluated.
However, for an array containing only positive even integers, \texttt{x[i] \% 2 == 1}
evaluates to false for every element in both the faulty implementation and the corrected
implementation (which uses \texttt{x[i] \% 2 != 0}). The elements are still counted
because \texttt{x[i] > 0} is true for each element, so the control flow and final
\texttt{count} are identical in both implementations. Therefore, no error state is reached.

\subsubsection{d)}
A test case that results in an error state but not a failure does not exist.

\begin{adjustwidth}{2em}{0pt}{

    The fault only affects the classification of negative odd integers.
    For any test case containing a negative odd value (like \texttt{-3}),
    the faulty predicate \texttt{x[i] \% 2 == 1} evaluates to false, whereas
    the corrected predicate, \texttt{x[i] \% 2 != 0}, would evaluate to true.

    This causes \texttt{count} to be smaller than it should be, producing an
    error state. Since \texttt{count} is only incremented and never corrected later,
    the final returned value must also be smaller than the correct value.

    Therefore, any error state necessarily results in a failure, and no such test case exists.

}\end{adjustwidth}

\subsubsection{e)}

For the given test case, the first error state occurs when \texttt{i = 0}
and the conditional \texttt{x[i] \% 2 == 1 || x[i] > 0} is evaluated for
\texttt{x[0] = -3}. In the provided incorrect implementation,
\texttt{-3 \% 2 == 1} evaluates to false (since \texttt{-3 \% 2 == -1} in Java),
and \texttt{-3 > 0} is also false, so the program does not increment
\texttt{count}. In the corrected implementation (using \texttt{x[i] \% 2 != 0}),
the oddness check would evaluate to true and the program would increment
\texttt{count}.

Therefore, the first error state is the incorrect state of \texttt{count = 0}
after processing index \texttt{0}. 

\section{Testing parts of large systems}

\subsection{a)}

To decouple the agents' behaviour from the core game dynamics,
I would ensure that the core module interacts with agents only through the
\texttt{CatanAgent} interface, without depending on any specific implementation.

The core module enforces the core game dynamics such as
invoking agents when it is their turn, applying their actions,
checking if actions are legal, updating the \texttt{GameState}, distributing resources,
and enforcing trade/discard/other rules. 

The agents are responsible only for
selecting actions through methods such as \texttt{chooseMove},
\texttt{chooseDiscard}, and \texttt{chooseResource}.

Since the current goal is only to verify that agents \emph{can} execute
these actions, not whether they choose useful actions, I would provide a simplified
test double (specifically, a stub) of \texttt{CatanAgent} for testing purposes. 
This implementation would return predictable, pre-scripted actions without
any strategic logic (for example, always selecting the first legal move).

This approach follows the testing principle of isolating the unit under test.
By replacing complex agent logic with a simple test implementation,
the core module can be tested independently of any learning or strategic
behaviour. This ensures that failures during testing reflect problems in the
core game dynamics rather than in the agents' decision-making logic.

\subsection{b)}

\begin{verbatim}
public class StubAgent implements CatanAgent {

    private int playerId;

    @Override
    public void init(int playerId) {
        this.playerId = playerId;
    }

    @Override
    public Move chooseInitialSettlement(GameState state) {
        // Assuming new Move() creates a valid default move 
        return new Move();
    }

    @Override
    public Move chooseInitialRoad(GameState state) {
        return new Move();
    }

    @Override
    public Move chooseMove(GameState state) {
        return new Move();
    }

    @Override
    public Map<ResourceType, Integer> chooseDiscard(
            GameState state, int discardCount) {

        // Empty discard map for testing
        return new HashMap<>();
    }

    @Override
    public ResourceType chooseResource(GameState state) {
        return ResourceType.BRICK;
    }

    @Override
    public int chooseRobberTarget(
            GameState state, List<Integer> possibleTargets) {

        // Assuming for testing that possibleTargets is non-empty
        // and contains valid player IDs
        return possibleTargets.get(0);
    }

    @Override
    public DevelopmentCard chooseDevelopmentCard(GameState state) {
        return null;
    }
}
\end{verbatim}

\subsection{c)}

Other solutions include:
\begin{itemize}
    \item Implement simple rule-based decision logic for agents, and use this during early testing.
    \item Capture a sequence of agent decisions from a run and replay them deterministically as regression tests.
    \item Rely primarily on end-to-end system tests (run full games with real agents) once all components exist.
\end{itemize}

A solution I would anticipate from a developer unfamiliar with test doubles and isolation is to
implement the learning agent first and then test the system by running full 
games end-to-end, attempting to break things at the system level and debugging issues as they appear.

Points against that approach and in favor of using a stub test double:
\begin{enumerate}
    \item End-to-end failures do not clearly indicate whether the defect is in the core 
    game dynamics or in the agent logic. Since the stub has minimal logic and
    predictable behaviour, any failures during testing can be confidently
    attributed to the core dynamics rather than the agent's decision-making.
    \item Learning-based or complex agents may behave differently across runs, making 
    failures hard to reproduce. A stub provides deterministic, repeatable behaviour, 
    which is crucial for automated regression testing.
    \item Full-game system tests are slower to run and harder to set up than focused 
    tests of the core module. Isolated tests with test doubles provide faster feedback 
    during development and can be run frequently.
    \item With end-to-end gameplay, important edge cases may not occur reliably. 
    With a stub agent, tests can deliberately trigger specific actions and scenarios
    to ensure the core dynamics are exercised to a sufficient degree of coverage.
\end{enumerate}

\subsection{d)}
If no one on the team is familiar with test doubles/isolation, I would treat it as a
process and knowledge gap and address it directly.

!!!research ceab stuff so u can quote it and explain how it gets addressed in ur answer!!!
!!!...cite ceab? idk or just say according to ceab we have a duty to x y z i do that here
by doing x y z!!

\section{Test driven development (TDD)}

\section{Test coverage and AI}
 